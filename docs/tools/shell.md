# Инструмент оболочки (`run_shell_command`)

Этот документ описывает инструмент `run_shell_command` для Gemini CLI.

## Описание

Используйте `run_shell_command` для взаимодействия с базовой системой, запуска скриптов или выполнения операций командной строки. `run_shell_command` выполняет заданную команду оболочки. В Windows команда будет выполняться с помощью `cmd.exe /c`. На других платформах команда будет выполняться с помощью `bash -c`.

### Аргументы

`run_shell_command` принимает следующие аргументы:

- `command` (строка, обязательный): Точная команда оболочки для выполнения.
- `description` (строка, необязательный): Краткое описание назначения команды, которое будет показано пользователю.
- `directory` (строка, необязательный): Каталог (относительно корня проекта), в котором будет выполняться команда. Если не указано, команда выполняется в корне проекта.

## Как использовать `run_shell_command` с Gemini CLI

При использовании `run_shell_command` команда выполняется как подпроцесс. `run_shell_command` может запускать фоновые процессы с помощью `&`. Инструмент возвращает подробную информацию о выполнении, включая:

- `Command`: Выполненная команда.
- `Directory`: Каталог, в котором была выполнена команда.
- `Stdout`: Вывод из стандартного потока вывода.
- `Stderr`: Вывод из стандартного потока ошибок.
- `Error`: Любое сообщение об ошибке, сообщенное подпроцессом.
- `Exit Code`: Код выхода команды.
- `Signal`: Номер сигнала, если команда была завершена сигналом.
- `Background PIDs`: Список PID для любых запущенных фоновых процессов.

Использование:

```
run_shell_command(command="Ваши команды.", description="Ваше описание команды.", directory="Ваш каталог выполнения.")
```

## Примеры `run_shell_command`

Вывести список файлов в текущем каталоге:

```
run_shell_command(command="ls -la")
```

Запустить скрипт в определенном каталоге:

```
run_shell_command(command="./my_script.sh", directory="scripts", description="Запустить мой пользовательский скрипт")
```

Запустить фоновый сервер:

```
run_shell_command(command="npm run dev &", description="Запустить сервер разработки в фоновом режиме")
```

## Важные примечания

- **Безопасность:** Будьте осторожны при выполнении команд, особенно тех, которые формируются из пользовательского ввода, чтобы предотвратить уязвимости безопасности.
- **Интерактивные команды:** Избегайте команд, требующих интерактивного ввода пользователя, так как это может привести к зависанию инструмента. Используйте неинтерактивные флаги, если они доступны (например, `npm init -y`).
- **Обработка ошибок:** Проверяйте поля `Stderr`, `Error` и `Exit Code`, чтобы определить, успешно ли выполнена команда.
- **Фоновые процессы:** Когда команда запускается в фоновом режиме с `&`, инструмент немедленно вернется, и процесс продолжит выполняться в фоновом режиме. Поле `Background PIDs` будет содержать идентификатор процесса фонового процесса.

## Переменные среды

Когда `run_shell_command` выполняет команду, он устанавливает переменную среды `GEMINI_CLI=1` в среде подпроцесса. Это позволяет скриптам или инструментам определять, запускаются ли они из Gemini CLI.

## Ограничения команд

Вы можете ограничить команды, которые могут быть выполнены инструментом `run_shell_command`, используя настройки `coreTools` и `excludeTools` в вашем файле конфигурации.

- `coreTools`: Чтобы ограничить `run_shell_command` определенным набором команд, добавьте записи в список `coreTools` в формате `run_shell_command(<command>)`. Например, `"coreTools": ["run_shell_command(git)"]` разрешит только команды `git`. Включение универсального `run_shell_command` действует как подстановочный знак, разрешая любую команду, не заблокированную явно.
- `excludeTools`: Чтобы заблокировать определенные команды, добавьте записи в список `excludeTools` в формате `run_shell_command(<command>)`. Например, `"excludeTools": ["run_shell_command(rm)"]` заблокирует команды `rm`.

Логика проверки разработана таким образом, чтобы быть безопасной и гибкой:

1.  **Отключение цепочки команд**: Инструмент автоматически разделяет команды, связанные с `&&`, `||` или `;`, и проверяет каждую часть отдельно. Если какая-либо часть цепочки запрещена, вся команда блокируется.
2.  **Сопоставление префиксов**: Инструмент использует сопоставление префиксов. Например, если вы разрешаете `git`, вы можете запустить `git status` или `git log`.
3.  **Приоритет черного списка**: Список `excludeTools` всегда проверяется первым. Если команда соответствует заблокированному префиксу, она будет отклонена, даже если она также соответствует разрешенному префиксу в `coreTools`.

### Примеры ограничений команд

**Разрешить только определенные префиксы команд**

Чтобы разрешить только команды `git` и `npm` и заблокировать все остальные:

```json
{
  "coreTools": ["run_shell_command(git)", "run_shell_command(npm)"]
}
```

- `git status`: Разрешено
- `npm install`: Разрешено
- `ls -l`: Заблокировано

**Заблокировать определенные префиксы команд**

Чтобы заблокировать `rm` и разрешить все остальные команды:

```json
{
  "coreTools": ["run_shell_command"],
  "excludeTools": ["run_shell_command(rm)"]
}
```

- `rm -rf /`: Заблокировано
- `git status`: Разрешено
- `npm install`: Разрешено

**Приоритет черного списка**

Если префикс команды находится как в `coreTools`, так и в `excludeTools`, он будет заблокирован.

```json
{
  "coreTools": ["run_shell_command(git)"],
  "excludeTools": ["run_shell_command(git push)"]
}
```

- `git push origin main`: Заблокировано
- `git status`: Разрешено

**Заблокировать все команды оболочки**

Чтобы заблокировать все команды оболочки, добавьте подстановочный знак `run_shell_command` в `excludeTools`:

```json
{
  "excludeTools": ["run_shell_command"]
}
```

- `ls -l`: Заблокировано
- `любая другая команда`: Заблокировано

## Примечание по безопасности для `excludeTools`

Ограничения для конкретных команд в
`excludeTools` для `run_shell_command` основаны на простом сопоставлении строк и могут быть легко обойдены. Эта функция **не является механизмом безопасности** и не должна использоваться для безопасного выполнения недоверенного кода. Рекомендуется использовать `coreTools` для явного выбора команд,
которые могут быть выполнены.
