# Инструменты файловой системы Gemini CLI

Gemini CLI предоставляет полный набор инструментов для взаимодействия с локальной файловой системой. Эти инструменты позволяют модели Gemini читать, записывать, перечислять, искать и изменять файлы и каталоги, все под вашим контролем и, как правило, с подтверждением для конфиденциальных операций.

**Примечание:** Все инструменты файловой системы работают в пределах `rootDirectory` (обычно текущий рабочий каталог, из которого вы запустили CLI) для обеспечения безопасности. Пути, которые вы предоставляете этим инструментам, как правило, должны быть абсолютными или разрешаться относительно этого корневого каталога.

## 1. `list_directory` (ReadFolder)

`list_directory` перечисляет имена файлов и подкаталогов непосредственно в указанном пути к каталогу. Он может опционально игнорировать записи, соответствующие предоставленным шаблонам glob.

- **Имя инструмента:** `list_directory`
- **Отображаемое имя:** ReadFolder
- **Файл:** `ls.ts`
- **Параметры:**
  - `path` (строка, обязательный): Абсолютный путь к каталогу для перечисления.
  - `ignore` (массив строк, необязательный): Список шаблонов glob для исключения из списка (например, `["*.log", ".git"]`).
  - `respect_git_ignore` (логическое значение, необязательный): Учитывать ли шаблоны `.gitignore` при перечислении файлов. По умолчанию `true`.
- **Поведение:**
  - Возвращает список имен файлов и каталогов.
  - Указывает, является ли каждая запись каталогом.
  - Сортирует записи: сначала каталоги, затем по алфавиту.
- **Вывод (`llmContent`):** Строка типа: `Список каталогов для /path/to/your/folder:\n[DIR] subfolder1\nfile1.txt\nfile2.png`
- **Подтверждение:** Нет.

## 2. `read_file` (ReadFile)

`read_file` читает и возвращает содержимое указанного файла. Этот инструмент обрабатывает текстовые файлы, изображения (PNG, JPG, GIF, WEBP, SVG, BMP) и PDF-файлы. Для текстовых файлов он может читать определенные диапазоны строк. Другие типы бинарных файлов обычно пропускаются.

- **Имя инструмента:** `read_file`
- **Отображаемое имя:** ReadFile
- **Файл:** `read-file.ts`
- **Параметры:**
  - `path` (строка, обязательный): Абсолютный путь к файлу для чтения.
  - `offset` (число, необязательный): Для текстовых файлов, 0-базовый номер строки, с которой начинается чтение. Требует установки `limit`.
  - `limit` (число, необязательный): Для текстовых файлов, максимальное количество строк для чтения. Если опущено, читает максимальное количество по умолчанию (например, 2000 строк) или весь файл, если это возможно.
- **Поведение:**
  - Для текстовых файлов: Возвращает содержимое. Если используются `offset` и `limit`, возвращает только этот фрагмент строк. Указывает, было ли содержимое усечено из-за ограничений по строкам или длине строк.
  - Для файлов изображений и PDF: Возвращает содержимое файла в виде структуры данных, закодированной в base64, подходящей для использования моделью.
  - Для других бинарных файлов: Пытается идентифицировать и пропустить их, возвращая сообщение, указывающее, что это общий бинарный файл.
- **Вывод:** (`llmContent`):
  - Для текстовых файлов: Содержимое файла, возможно, с префиксом сообщения об усечении (например, `[Содержимое файла усечено: показаны строки 1-100 из 500 общих строк...]
Фактическое содержимое файла...`).
  - Для файлов изображений/PDF: Объект, содержащий `inlineData` с `mimeType` и base64 `data` (например, `{ inlineData: { mimeType: 'image/png', data: 'base64encodedstring' } }`).
  - Для других бинарных файлов: Сообщение типа `Невозможно отобразить содержимое бинарного файла: /path/to/data.bin`.
- **Подтверждение:** Нет.

## 3. `write_file` (WriteFile)

`write_file` записывает содержимое в указанный файл. Если файл существует, он будет перезаписан. Если файл не существует, он (и любые необходимые родительские каталоги) будет создан.

- **Имя инструмента:** `write_file`
- **Отображаемое имя:** WriteFile
- **Файл:** `write-file.ts`
- **Параметры:**
  - `file_path` (строка, обязательный): Абсолютный путь к файлу для записи.
  - `content` (строка, обязательный): Содержимое для записи в файл.
- **Поведение:**
  - Записывает предоставленное `content` в `file_path`.
  - Создает родительские каталоги, если они не существуют.
- **Вывод (`llmContent`):** Сообщение об успехе, например, `Файл успешно перезаписан: /path/to/your/file.txt` или `Новый файл успешно создан и записан: /path/to/new/file.txt`.
- **Подтверждение:** Да. Показывает разницу изменений и запрашивает подтверждение пользователя перед записью.

## 4. `glob` (FindFiles)

`glob` находит файлы, соответствующие определенным шаблонам glob (например, `src/**/*.ts`, `*.md`), возвращая абсолютные пути, отсортированные по времени изменения (сначала самые новые).

- **Имя инструмента:** `glob`
- **Отображаемое имя:** FindFiles
- **Файл:** `glob.ts`
- **Параметры:**
  - `pattern` (строка, обязательный): Шаблон glob для сопоставления (например, `"*.py"`, `"src/**/*.js"`).
  - `path` (строка, необязательный): Абсолютный путь к каталогу для поиска. Если опущено, ищет в корневом каталоге инструмента.
  - `case_sensitive` (логическое значение, необязательный): Должен ли поиск быть чувствительным к регистру. По умолчанию `false`.
  - `respect_git_ignore` (логическое значение, необязательный): Учитывать ли шаблоны .gitignore при поиске файлов. По умолчанию `true`.
- **Поведение:**
  - Ищет файлы, соответствующие шаблону glob, в указанном каталоге.
  - Возвращает список абсолютных путей, отсортированных по дате последнего изменения (сначала самые новые).
  - По умолчанию игнорирует распространенные каталоги, такие как `node_modules` и `.git`.
- **Вывод (`llmContent`):** Сообщение типа: `Найдено 5 файлов, соответствующих "*.ts" в src, отсортированных по времени изменения (сначала самые новые):\nsrc/file1.ts\nsrc/subdir/file2.ts...`
- **Подтверждение:** Нет.

## 5. `search_file_content` (SearchText)

`search_file_content` ищет шаблон регулярного выражения в содержимом файлов в указанном каталоге. Может фильтровать файлы по шаблону glob. Возвращает строки, содержащие совпадения, а также их пути к файлам и номера строк.

- **Имя инструмента:** `search_file_content`
- **Отображаемое имя:** SearchText
- **Файл:** `grep.ts`
- **Параметры:**
  - `pattern` (строка, обязательный): Регулярное выражение (regex) для поиска (например, `"function\s+myFunction"`).
  - `path` (строка, необязательный): Абсолютный путь к каталогу для поиска. По умолчанию текущий рабочий каталог.
  - `include` (строка, необязательный): Шаблон glob для фильтрации файлов, которые будут искаться (например, `"*.js"`, `"src/**/*.{ts,tsx}"`). Если опущено, ищет большинство файлов (с учетом общих исключений).
- **Поведение:**
  - Использует `git grep`, если доступен в репозитории Git, для скорости; в противном случае возвращается к системному `grep` или поиску на основе JavaScript.
  - Возвращает список совпадающих строк, каждая из которых имеет префикс с путем к файлу (относительно каталога поиска) и номером строки.
- **Вывод (`llmContent`):** Отформатированная строка совпадений, например:
  ```
  Найдено 3 совпадения для шаблона "myFunction" в пути "." (фильтр: "*.ts"):
  ---
  Файл: src/utils.ts
  L15: export function myFunction() {
  L22:   myFunction.call();
  ---
  Файл: src/index.ts
  L5: import { myFunction } from './utils';
  ---
  ```
- **Подтверждение:** Нет.

## 6. `replace` (Edit)

`replace` заменяет текст в файле. По умолчанию заменяет одно вхождение, но может заменять несколько вхождений, если указано `expected_replacements`. Этот инструмент предназначен для точных, целевых изменений и требует значительного контекста вокруг `old_string`, чтобы гарантировать изменение правильного места.

- **Имя инструмента:** `replace`
- **Отображаемое имя:** Edit
- **Файл:** `edit.ts`
- **Параметры:**
  - `file_path` (строка, обязательный): Абсолютный путь к файлу для изменения.
  - `old_string` (строка, обязательный): Точный буквальный текст для замены.

    **ВАЖНО:** Эта строка должна однозначно идентифицировать единственное вхождение для изменения. Она должна включать не менее 3 строк контекста _до_ и _после_ целевого текста, точно соответствуя пробелам и отступам. Если `old_string` пуст, инструмент пытается создать новый файл по `file_path` с `new_string` в качестве содержимого.

  - `new_string` (строка, обязательный): Точный буквальный текст для замены `old_string`.
  - `expected_replacements` (число, необязательный): Количество ожидаемых замен. По умолчанию `1`.

- **Поведение:**
  - Если `old_string` пуст и `file_path` не существует, создает новый файл с `new_string` в качестве содержимого.
  - Если `old_string` предоставлен, он читает `file_path` и пытается найти ровно одно вхождение `old_string`.
  - Если найдено одно вхождение, оно заменяется на `new_string`.
  - **Улучшенная надежность (многоэтапная коррекция редактирования):** Для значительного повышения успешности редактирования, особенно когда предоставленная моделью `old_string` может быть не идеально точной, инструмент включает механизм многоэтапной коррекции редактирования.
    - Если исходная `old_string` не найдена или соответствует нескольким местам, инструмент может использовать модель Gemini для итеративного уточнения `old_string` (и, возможно, `new_string`).
    - Этот процесс самокоррекции пытается идентифицировать уникальный сегмент, который модель намеревалась изменить, делая операцию `replace` более надежной даже при слегка неточном исходном контексте.
- **Условия отказа:** Несмотря на механизм коррекции, инструмент завершится сбоем, если:
  - `file_path` не является абсолютным или находится за пределами корневого каталога.
  - `old_string` не пуст, но `file_path` не существует.
  - `old_string` пуст, но `file_path` уже существует.
  - `old_string` не найден в файле после попыток его исправить.
  - `old_string` найден несколько раз, и механизм самокоррекции не может разрешить его до одного, однозначного совпадения.
- **Вывод (`llmContent`):**
  - При успехе: `Файл успешно изменен: /path/to/file.txt (1 замена).` или `Создан новый файл: /path/to/new_file.txt с предоставленным содержимым.`
  - При сбое: Сообщение об ошибке, объясняющее причину (например, `Не удалось отредактировать, найдено 0 вхождений...`, `Не удалось отредактировать, ожидалось 1 вхождение, но найдено 2...`).
- **Подтверждение:** Да. Показывает разницу предлагаемых изменений и запрашивает подтверждение пользователя перед записью в файл.

Эти инструменты файловой системы обеспечивают основу для Gemini CLI, чтобы понимать и взаимодействовать с контекстом вашего локального проекта.
