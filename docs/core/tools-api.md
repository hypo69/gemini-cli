# Ядро Gemini CLI: API инструментов

Ядро Gemini CLI (`packages/core`) содержит надежную систему для определения, регистрации и выполнения инструментов. Эти инструменты расширяют возможности модели Gemini, позволяя ей взаимодействовать с локальной средой, получать веб-контент и выполнять различные действия, выходящие за рамки простой генерации текста.

## Основные концепции

- **Инструмент (`tools.ts`):** Интерфейс и базовый класс (`BaseTool`), который определяет контракт для всех инструментов. Каждый инструмент должен иметь:
  - `name`: Уникальное внутреннее имя (используется в вызовах API к Gemini).
  - `displayName`: Удобное для пользователя имя.
  - `description`: Четкое объяснение того, что делает инструмент, которое предоставляется модели Gemini.
  - `parameterSchema`: Схема JSON, определяющая параметры, которые принимает инструмент. Это крайне важно для того, чтобы модель Gemini правильно понимала, как вызывать инструмент.
  - `validateToolParams()`: Метод для проверки входящих параметров.
  - `getDescription()`: Метод для предоставления удобочитаемого описания того, что инструмент будет делать с конкретными параметрами перед выполнением.
  - `shouldConfirmExecute()`: Метод для определения, требуется ли подтверждение пользователя перед выполнением (например, для потенциально деструктивных операций).
  - `execute()`: Основной метод, который выполняет действие инструмента и возвращает `ToolResult`.

- **`ToolResult` (`tools.ts`):** Интерфейс, определяющий структуру результата выполнения инструмента:
  - `llmContent`: Фактическое строковое содержимое, которое будет включено в историю, отправленную обратно в LLM для контекста.
  - `returnDisplay`: Удобная для пользователя строка (часто Markdown) или специальный объект (например, `FileDiff`) для отображения в CLI.

- **Реестр инструментов (`tool-registry.ts`):** Класс (`ToolRegistry`), отвечающий за:
  - **Регистрация инструментов:** Хранение коллекции всех доступных встроенных инструментов (например, `ReadFileTool`, `ShellTool`).
  - **Обнаружение инструментов:** Он также может обнаруживать инструменты динамически:
    - **Обнаружение на основе команд:** Если `toolDiscoveryCommand` настроен в параметрах, эта команда выполняется. Ожидается, что она выведет JSON, описывающий пользовательские инструменты, которые затем регистрируются как экземпляры `DiscoveredTool`. Соответствующая `toolCallCommand` затем будет отвечать за фактическое выполнение этих пользовательских инструментов.
    - **Обнаружение на основе MCP:** Если `mcpServerCommand` настроен, реестр может подключаться к серверу Model Context Protocol (MCP) для перечисления и регистрации инструментов (`DiscoveredMCPTool`).
  - **Предоставление схем:** Предоставление схем `FunctionDeclaration` всех зарегистрированных инструментов модели Gemini, чтобы она знала, какие инструменты доступны и как их использовать.
  - **Получение инструментов:** Позволяет ядру получать конкретный инструмент по имени для выполнения.

## Встроенные инструменты

Ядро поставляется с набором предопределенных инструментов, обычно находящихся в `packages/core/src/tools/`. К ним относятся:

- **Инструменты файловой системы:**
  - `LSTool` (`ls.ts`): Перечисляет содержимое каталога.
  - `ReadFileTool` (`read-file.ts`): Читает содержимое одного файла. Принимает параметр `absolute_path`, который должен быть абсолютным путем.
  - `WriteFileTool` (`write-file.ts`): Записывает содержимое в файл.
  - `GrepTool` (`grep.ts`): Ищет шаблоны в файлах.
  - `GlobTool` (`glob.ts`): Находит файлы, соответствующие шаблонам glob.
  - `EditTool` (`edit.ts`): Выполняет изменения файлов на месте (часто требует подтверждения).
  - `ReadManyFilesTool` (`read-many-files.ts`): Читает и объединяет содержимое из нескольких файлов или шаблонов glob (используется командой `@` в CLI).
- **Инструменты выполнения:**
  - `ShellTool` (`shell.ts`): Выполняет произвольные команды оболочки (требует тщательной песочницы и подтверждения пользователя).
- **Веб-инструменты:**
  - `WebFetchTool` (`web-fetch.ts`): Получает содержимое из URL.
  - `WebSearchTool` (`web-search.ts`): Выполняет веб-поиск.
- **Инструменты памяти:**
  - `MemoryTool` (`memoryTool.ts`): Взаимодействует с памятью ИИ.

Каждый из этих инструментов расширяет `BaseTool` и реализует необходимые методы для своей специфической функциональности.

## Поток выполнения инструмента

1.  **Запрос модели:** Модель Gemini, основываясь на запросе пользователя и предоставленных схемах инструментов, решает использовать инструмент и возвращает часть `FunctionCall` в своем ответе, указывая имя инструмента и аргументы.
2.  **Ядро получает запрос:** Ядро анализирует этот `FunctionCall`.
3.  **Получение инструмента:** Оно ищет запрошенный инструмент в `ToolRegistry`.
4.  **Проверка параметров:** Вызывается метод `validateToolParams()` инструмента.
5.  **Подтверждение (если требуется):**
    - Вызывается метод `shouldConfirmExecute()` инструмента.
    - Если он возвращает детали для подтверждения, ядро передает это обратно в CLI, который запрашивает пользователя.
    - Решение пользователя (например, продолжить, отменить) отправляется обратно в ядро.
6.  **Выполнение:** Если проверено и подтверждено (или если подтверждение не требуется), ядро вызывает метод `execute()` инструмента с предоставленными аргументами и `AbortSignal` (для возможной отмены).
7.  **Обработка результата:** `ToolResult` из `execute()` принимается ядром.
8.  **Ответ модели:** `llmContent` из `ToolResult` упаковывается как `FunctionResponse` и отправляется обратно в модель Gemini, чтобы она могла продолжить генерировать ответ для пользователя.
9.  **Отображение пользователю:** `returnDisplay` из `ToolResult` отправляется в CLI, чтобы показать пользователю, что сделал инструмент.

## Расширение с помощью пользовательских инструментов

Хотя прямая программная регистрация новых инструментов пользователями не детализируется явно как основной рабочий процесс в предоставленных файлах для обычных конечных пользователей, архитектура поддерживает расширение через:

- **Обнаружение на основе команд:** Опытные пользователи или администраторы проекта могут определить `toolDiscoveryCommand` в `settings.json`. Эта команда, при запуске ядром Gemini CLI, должна выводить массив JSON объектов `FunctionDeclaration`. Затем ядро сделает их доступными как экземпляры `DiscoveredTool`. Соответствующая `toolCallCommand` затем будет отвечать за фактическое выполнение этих пользовательских инструментов.
- **MCP-сервер(ы):** Для более сложных сценариев один или несколько MCP-серверов могут быть настроены через параметр `mcpServers` в `settings.json`. Ядро Gemini CLI затем может обнаруживать и использовать инструменты, предоставляемые этими серверами. Как упоминалось, если у вас есть несколько MCP-серверов, имена инструментов будут иметь префикс с именем сервера из вашей конфигурации (например, `serverAlias__actualToolName`).

Эта система инструментов обеспечивает гибкий и мощный способ расширения возможностей модели Gemini, делая Gemini CLI универсальным помощником для широкого круга задач.
