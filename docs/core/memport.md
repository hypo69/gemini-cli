# Процессор импорта памяти

Процессор импорта памяти — это функция, которая позволяет модулировать файлы GEMINI.md путем импорта содержимого из других файлов с использованием синтаксиса `@file.md`.

## Обзор

Эта функция позволяет разбивать большие файлы GEMINI.md на более мелкие, более управляемые компоненты, которые могут быть повторно использованы в различных контекстах. Процессор импорта поддерживает как относительные, так и абсолютные пути, со встроенными функциями безопасности для предотвращения циклических импортов и обеспечения безопасности доступа к файлам.

## Синтаксис

Используйте символ `@`, за которым следует путь к файлу, который вы хотите импортировать:

```markdown
# Основной файл GEMINI.md

Это основное содержимое.

@./components/instructions.md

Больше содержимого здесь.

@./shared/configuration.md
```

## Поддерживаемые форматы путей

### Относительные пути

- `@./file.md` - Импорт из того же каталога
- `@../file.md` - Импорт из родительского каталога
- `@./components/file.md` - Импорт из подкаталога

### Абсолютные пути

- `@/absolute/path/to/file.md` - Импорт с использованием абсолютного пути

## Примеры

### Базовый импорт

```markdown
# Мой GEMINI.md

Добро пожаловать в мой проект!

@./getting-started.md

## Функции

@./features/overview.md
```

### Вложенные импорты

Импортированные файлы сами могут содержать импорты, создавая вложенную структуру:

```markdown
# main.md

@./header.md
@./content.md
@./footer.md
```

```markdown
# header.md

# Заголовок проекта

@./shared/title.md
```

## Функции безопасности

### Обнаружение циклических импортов

Процессор автоматически обнаруживает и предотвращает циклические импорты:

```markdown
# file-a.md

@./file-b.md

# file-b.md

@./file-a.md <!-- Это будет обнаружено и предотвращено -->
```

### Безопасность доступа к файлам

Функция `validateImportPath` гарантирует, что импорт разрешен только из указанных каталогов, предотвращая доступ к конфиденциальным файлам за пределами разрешенной области.

### Максимальная глубина импорта

Для предотвращения бесконечной рекурсии существует настраиваемая максимальная глубина импорта (по умолчанию: 5 уровней).

## Обработка ошибок

### Отсутствующие файлы

Если файл, на который ссылается ссылка, не существует, импорт завершится сбоем с комментарием об ошибке в выводе.

### Ошибки доступа к файлам

Проблемы с разрешениями или другие ошибки файловой системы обрабатываются корректно с соответствующими сообщениями об ошибках.

## Обнаружение областей кода

Процессор импорта использует библиотеку `marked` для обнаружения блоков кода и встроенных фрагментов кода, гарантируя, что импорты `@` внутри этих областей правильно игнорируются. Это обеспечивает надежную обработку вложенных блоков кода и сложных структур Markdown.

## Структура дерева импорта

Процессор возвращает дерево импорта, которое показывает иерархию импортированных файлов, аналогично функции `/memory` Claude. Это помогает пользователям отлаживать проблемы с файлами GEMINI.md, показывая, какие файлы были прочитаны и их отношения импорта.

Пример структуры дерева:

```
Файлы памяти
 L проект: GEMINI.md
            L a.md
              L b.md
                L c.md
              L d.md
                L e.md
                  L f.md
            L включено.md
```

Дерево сохраняет порядок импорта файлов и показывает полную цепочку импорта для целей отладки.

## Сравнение с подходом `/memory` Claude Code (`claude.md`)

Функция `/memory` Claude Code (как видно в `claude.md`) создает плоский, линейный документ путем объединения всех включенных файлов, всегда отмечая границы файлов четкими комментариями и именами путей. Она не явно представляет иерархию импорта, но LLM получает все содержимое файлов и пути, что достаточно для восстановления иерархии при необходимости.

Примечание: Дерево импорта в основном предназначено для ясности во время разработки и имеет ограниченное отношение к потреблению LLM.

## Справочник API

### `processImports(content, basePath, debugMode?, importState?)`

Обрабатывает операторы импорта в содержимом GEMINI.md.

**Параметры:**

- `content` (строка): Содержимое для обработки импортов
- `basePath` (строка): Путь к каталогу, где находится текущий файл
- `debugMode` (логическое значение, необязательный): Включить ли отладочное логирование (по умолчанию: false)
- `importState` (ImportState, необязательный): Отслеживание состояния для предотвращения циклических импортов

**Возвращает:** Promise<ProcessImportsResult> - Объект, содержащий обработанное содержимое и дерево импорта

### `ProcessImportsResult`

```typescript
interface ProcessImportsResult {
  content: string; // Обработанное содержимое с разрешенными импортами
  importTree: MemoryFile; // Структура дерева, показывающая иерархию импорта
}
```

### `MemoryFile`

```typescript
interface MemoryFile {
  path: string; // Путь к файлу
  imports?: MemoryFile[]; // Прямые импорты, в порядке их импорта
}
```

### `validateImportPath(importPath, basePath, allowedDirectories)`

Проверяет пути импорта, чтобы убедиться, что они безопасны и находятся в разрешенных каталогах.

**Параметры:**

- `importPath` (строка): Путь импорта для проверки
- `basePath` (строка): Базовый каталог для разрешения относительных путей
- `allowedDirectories` (массив строк): Массив разрешенных путей к каталогам

**Возвращает:** boolean - Является ли путь импорта действительным

### `findProjectRoot(startDir)`

Находит корень проекта, ища каталог `.git` вверх от заданного начального каталога. Реализована как **асинхронная** функция, использующая неблокирующие API файловой системы, чтобы избежать блокировки цикла событий Node.js.

**Параметры:**

- `startDir` (строка): Каталог, с которого начинается поиск

**Возвращает:** Promise<string> - Корневой каталог проекта (или начальный каталог, если `.git` не найден)

## Лучшие практики

1. **Используйте описательные имена файлов** для импортированных компонентов
2. **Держите импорты неглубокими** - избегайте глубоко вложенных цепочек импорта
3. **Документируйте свою структуру** - поддерживайте четкую иерархию импортированных файлов
4. **Тестируйте свои импорты** - убедитесь, что все ссылающиеся файлы существуют и доступны
5. **Используйте относительные пути**, когда это возможно, для лучшей переносимости

## Устранение неполадок

### Распространенные проблемы

1. **Импорт не работает**: Убедитесь, что файл существует и путь правильный
2. **Предупреждения о циклических импортах**: Проверьте структуру импорта на наличие циклических ссылок
3. **Ошибки разрешений**: Убедитесь, что файлы доступны для чтения и находятся в разрешенных каталогах
4. **Проблемы с разрешением путей**: Используйте абсолютные пути, если относительные пути не разрешаются правильно

### Режим отладки

Включите режим отладки, чтобы увидеть подробное логирование процесса импорта:

```typescript
const result = await processImports(content, basePath, true);
```
